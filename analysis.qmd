---
title: "get_spatial_division"
author: "Olaf König"
format: 
  html:
    self-contained: TRUE
    page-layout: full
    toc: true
    toc-depth: 4
    number-sections: true
    number-depth: 4
    code-line-numbers: true
    code-fold: true
execute:
  warning: false
theme: cosmo 
editor: visual
---

# Libraries

```{r}

library(tidyverse)
library(tidylog)
library(readr)
library(DT)
library(ggbeeswarm)
library(plotly)
library(sf)
library(mapview)
```

# Data import

## Fonction de l'import

```{r}

import_selected_files <- function(directory) {
  # Lister les fichiers dans le répertoire
  files <- list.files(path = directory, pattern = "\\.csv$", full.names = TRUE)
  
  # Afficher la liste des fichiers
  cat("Fichiers disponibles :\n")
  for (i in seq_along(files)) {
    cat(i, ": ", basename(files[i]), "\n")
  }
  
  # Demander à l'utilisateur de sélectionner un ou plusieurs fichiers
  selections <- readline(prompt = "Sélectionnez un ou plusieurs fichiers (numéros séparés par des virgules (avec espace), sans guillemets) : ")
  
  # Convertir la sélection en un vecteur numérique
  selection_indices <- suppressWarnings(as.numeric(unlist(strsplit(selections, ","))))
  
  # Vérifier la sélection
  if (any(is.na(selection_indices)) || any(selection_indices < 1) || any(selection_indices > length(files))) {
    stop("Sélection invalide. Veuillez saisir des numéros valides, sans guillemets ni autres caractères.")
  }
  
  # Importer les fichiers sélectionnés et créer des objets
  imported_objects <- list()
  for (i in selection_indices) {
    selected_file <- files[i]
    file_name <- tools::file_path_sans_ext(basename(selected_file))
    
    # Importer le fichier et assigner l'objet
    assign(file_name, read_csv(selected_file), envir = .GlobalEnv)
    
    # Ajouter le nom de l'objet à la liste
    imported_objects[[file_name]] <- get(file_name)
  }
  
  # Retourner la liste des objets importés
  return(imported_objects)
}

```

## Appel de la fonction

```{r}
# Utilisation de la fonction
# Assurez-vous de spécifier le bon répertoire
objets_importes <- import_selected_files("data_input")
```

# Import des géodonnées

```{r}

g1g24_sf <- read_sf("data_input/g1g24.gpkg")
```

# Analyse

## Sélection de la catégorie 3 niveaux

```{r}

spatial_division_urbain_rural <- spatial_division_2024_03_01 %>%
  select(CODE_OFS, HR_GDETYP2012_L1, HR_GDETYP2012_L1_Name_fr)
```

## Liste des unités spatiales

```{r}

list_bfsnum_urbain <- spatial_division_urbain_rural %>% 
  filter(HR_GDETYP2012_L1 == 1) %>% 
  pull(CODE_OFS)

list_bfsnum_rural <- spatial_division_urbain_rural %>% 
  filter(HR_GDETYP2012_L1 == 3) %>% 
  pull(CODE_OFS)

list_bfsnum_intermediaire <- spatial_division_urbain_rural %>% 
  filter(HR_GDETYP2012_L1 == 2) %>% 
  pull(CODE_OFS)
```

## Sélection de votations types

```{r}

df_votes_2021_06_13_municipalities %>%  group_by(ballot_id, ballot_name) %>%  summarise() %>%  DT::datatable()
```

## Merge avec les catégories

```{r}

df_votes_pesticide <- df_votes_2021_06_13_municipalities %>%
  filter(
    ballot_id %in% c(6410, 6420)
  ) %>% 
  left_join(
    spatial_division_urbain_rural, by = c("id" = "CODE_OFS")
  ) %>%
  filter(!
    is.na(HR_GDETYP2012_L1_Name_fr)
  ) %>% 
  split(
    .$ballot_id
  )
```

## Création des objets SF avec les votations

```{r}

votes_pesticide_antibiotique_sf <- g1g24_sf %>% 
  left_join(df_votes_pesticide$`6410`, by = c("GMDNR" = "id"))


votes_pesticide_synthese_sf <- g1g24_sf %>% 
  left_join(df_votes_pesticide$`6420`, by = c("GMDNR" = "id"))
```

# Visualisation sous forme de beeswarm

Test avec d3

```{r}

df_votes_pesticide$`6410` %>% 
  select(name, HR_GDETYP2012_L1_Name_fr, yes_pct, voters) %>% 
  write_csv("data_output/votes_6410_data.csv")
```

#### Test avec ggplot

```{r}

beeswarm_test_1 <- ggplot(df_votes_pesticide$`6410`, aes(x = HR_GDETYP2012_L1_Name_fr, y = yes_pct, size = log10(voters), color = HR_GDETYP2012_L1_Name_fr)) +
  geom_beeswarm(alpha = 0.3) +
  theme_minimal() +
  labs(
    title = "Répartition des votes pour l'initiative «Pour une eau potable propre et une alimentation saine»",
    x = "Type de commune",
    y = "Pourcentage de 'Oui'",
    size = "Nombre d'électeurs"
  )

ggplotly(beeswarm_test_1)
```

```{r}

beeswarm_test_1 <- ggplot(df_votes_pesticide$`6410`, aes(x = HR_GDETYP2012_L1_Name_fr, y = yes_pct, size = sqrt(voters), color = HR_GDETYP2012_L1_Name_fr)) +
  geom_quasirandom(alpha = 0.6, method = "pseudorandom") +
  scale_size_continuous(range = c(0.5, 5)) +  # Ajustement de l'échelle de taille
  theme_minimal() +
  labs(
    title = "Répartition des votes pour l'initiative «Pour une eau potable propre et une alimentation saine»",
    x = "Type de commune",
    y = "Pourcentage de 'Oui'",
    size = "Nombre d'électeurs"
  )

  ggplotly(beeswarm_test_1)
```

```{r}

beeswarm_test_1 <- ggplot(df_votes_pesticide$`6410`, 
                          aes(x = HR_GDETYP2012_L1_Name_fr, 
                              y = yes_pct, 
                              size = sqrt(voters), 
                              color = HR_GDETYP2012_L1_Name_fr, 
                              text = paste("Commune: ", name, "<br>Oui %: ", yes_pct, "<br>Voters: ", voters))) +
  geom_quasirandom(alpha = 0.6, method = "pseudorandom") +
  scale_size_continuous(range = c(0.5, 5)) +  # Ajustement de l'échelle de taille
  theme_minimal() +
  labs(
    title = "Répartition des votes pour l'initiative «Pour une eau potable propre et une alimentation saine»",
    x = "Type de commune",
    y = "Pourcentage de 'Oui'",
    size = "Nombre d'électeurs"
  )

# Convertir en ggplotly avec le texte des communes
plotly_test <- ggplotly(beeswarm_test_1, tooltip = "text")

plotly_test

```

# Visualisation sous forme de cartes (mapview)

```{r}

library(RColorBrewer)

# Définir les breaks à des intervalles de 10 %
breaks <- seq(0, 100, by = 10)
# Utilisation de la palette PRGn avec 10 couleurs
palette_colors <- brewer.pal(11, "PRGn")

```

### Carte d'ensemble

```{r}

mapview(votes_pesticide_antibiotique_sf, 
          zcol = "yes_pct",
        at = breaks, 
        col.regions = palette_colors)
```

### Carte région urbaine

```{r}

votes_pesticide_antibiotique_sf %>% 
  filter(HR_GDETYP2012_L1 == 1) %>% 
  mapview(zcol = "yes_pct",
        at = breaks, 
        col.regions = palette_colors)
```

### Carte région intermédiaire

```{r}

votes_pesticide_antibiotique_sf %>% 
  filter(HR_GDETYP2012_L1 == 2) %>% 
  mapview(zcol = "yes_pct",
        at = breaks, 
        col.regions = palette_colors)
```

### Carte région rurale

```{r}

votes_pesticide_antibiotique_sf %>% 
  filter(HR_GDETYP2012_L1 == 3) %>% 
  mapview(zcol = "yes_pct",
        at = breaks, 
        col.regions = palette_colors)
```

# Visualisation sous forme de cartes (tmap)

### En carte choroplèthe

```{r}

library(tmap)

# Créer la carte avec tmap en utilisant small multiples (facets)
tm <- tm_shape(votes_pesticide_antibiotique_sf %>% 
                 filter(!is.na(yes_pct))) + 
  tm_polygons("yes_pct", 
              breaks = breaks, 
              palette = palette_colors) + 
  tm_facets(by = "HR_GDETYP2012_L1", 
            free.scales = FALSE, 
            ncol = 1) + 
  tm_layout(main.title = "Votes Pesticides et Antibiotiques par Degré d'Urbanité", 
            legend.outside = TRUE)

# Afficher la carte
tmap_mode("view") # Utiliser "plot" / "view" pour une carte statique
tm
```

### En cercles proportionnels

```{r}

tm <- tm_shape(votes_pesticide_antibiotique_sf %>% 
                  filter(!is.na(yes_pct))) + 
  tm_bubbles(size = "voters",     # Taille des cercles proportionnelle à 'yes_pct'
             col = "yes_pct",      # Couleur des cercles en fonction de 'yes_pct'
             breaks = breaks, 
             palette = palette_colors,
             scale = 2,            # Échelle des cercles
             border.col = "black", # Couleur de bordure des cercles
             style = "fixed") +    # Utilisation des breaks fixes
  tm_facets(by = "HR_GDETYP2012_L1", 
            free.scales = FALSE, 
            ncol = 1) + 
  tm_layout(main.title = "Votes Pesticides et Antibiotiques par Degré d'Urbanité avec Cercles Proportionnels", 
            legend.outside = TRUE)

# Afficher la carte
tm
```
